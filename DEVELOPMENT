Programs for PotatOS are simply just flat binaries. There are no
real rules how one uses the spaace in this binaries.
Important is only:
    1. software has to be 16-Bit (Real Mode, not DOS compatible)
    2. programs get loaded to 0x0000:0x9000
    3. you should exit by using AH=0;Int 0x21
    
To integrate your program into the build process, simply put the NASM
compatible asm-file into the 'Software/' directory.
When running 'sudo ./build.sh' it will be build and put onto the
floppy image.
Inside your program you can do some basic language dependent code.
The build script will give you a %define of the current language.
(
    e.g: %ifdef english
             message db "This is the english version.", 0x00
         %elifdef german
             message db "Das ist die Deutsche Version.", 0x00
         %endif
)


To make a program executable by the user it has to have the .bin extension
(this will be automatically done if you use the ./build.sh script)


To access the OS-API one can use the interrupt 0x21 (int 21).

To selected a routine you have to pass the function-code in the AH-register.
To pass parameters the remaining registers are used. In most of the cases
strings will be passed in the DX, and numbers in the (E)CX register.


The currently available routines are listet below.
Please note that the order may change in the future, as
they are really not sorrted.

AH = 0x00: exit programm
    BX <= error code (0 for no error)
    
    exits the calling program and jumps back to the command line.

AH = 0x01: print string
    DX <= string
    BL <= color code (*)
    
    Prints a \0-terminated string to the current cursor positon and 
    advances the cursor positon while doing so.
    (The color code is refering to the standart BIOS-color codes, which
    encode the foreground color in 4 bits and the background color in the
    other 4 bits)
    To use whatever color is currently the system standart, simply use
    the byte from address 0x0000:0x1FFF (1 byte)

AH = 0x02: compare string
    DI <= string 1
    SI <= string 2
    AL => 0 equal, 1 not equal
    
    Compares the two \0-terminated strings given in then DI- and SI-register.
    The result will be passed in the al-register, where 0 means equal and 1
    means not equal.

AH = 0x03: int to string [deprecated, use 0xAA instead]
    DX <= destination string
    CX <= 16-bit integer
    
    Converts whatever integer you pass in the CX-register in to a string.
    The string to use is indicated by the DX-register (warning: you have to
    make sure there is sufficient memory! Otherwise whatever DX points to 
    will be overriden!)
    The routine is capable of negative numbers, which is why the output
    ranges from -32768 to 32767.

AH = 0x04: keyboard input
    DX <= destination string
    CX <= char limit
    CX => char count
    
    Reads a string from the keyboard until the user presses enter and put
    the result into the string pointed to by DX (warning: you have to
    make sure there is sufficient memory! Otherwise whatever DX points to 
    will be overriden!). This routine will
    terminate the string with a \0-character.
    To limit how many chars can be entered, the register CX is used.
    In return, the CX-register contains the amout of characters actually read.

AH = 0x05: load file
    BX <= segmentaddress of destination buffer
    BP <= offsetaddress of destination buffer
    DX <= file name
    AX => status (0 = ok, -1 = error)
    CX => file size in bytes
    
    Loads a file from the floppy and puts in the memory at address BX:BP.
    As filename the string in DX is used. 
    If this is successful, AX is zeroed. Otherwise AX will be -1.
    The filesize is the size given by the file system (in theory that
    can be unaccurate).

AH = 0x06: time as string
    DX => time as string
    
    Converts the current system time to string and references to it in the
    DX-register. (you do not have to input an empty string here)
    The format is 'hh:mm Uhr' and is \0-termiatned.

AH = 0x07: date as string
    DX => date as string

    Converts the current system date to string and references to it in the
    DX-register. (you do not have to input an empty string here)
    The format is 'dd.mm.yyyy' and is \0-termiatned.

AH = 0x08: system version [deprecated]
    AH => major
    AL => minor

    Due to weird implementation this is not very accurate.

AH = 0x09: stringToInt [deprecated, use 0xBB instead]
    DX <= string
    CX => 16-bit integer
    AX => status (0 ok, -1 error)
    
    Tries to convert the string given in DX to an integer.
    This only reads until the first white-space appears.
    If the routine is successful, the result will be in the CX-register
    and AX will be zero.
    If an error occures, CX will be zero and AX will be -1.

AH = 0x0A: delete file
    DX <= filename
    AX => status (0 ok, 1 file not found, -1 error)
    
    Looks for the file with the filename determined by DX and deletes it.
    If the file does not exist, AX will be one and the routine returns.
    If the a generall error occures, AX will be -1.
    
    If the file is found, the routine will delete its cluster chain
    (the data itself may be recoverable)

AH = 0x0B: random number
    ECX <= random number

    Will generate a pseudo random number and return it in ECX.

AH = 0x0C: CPU info
    AX => CPU vendor
    BX => CPU model
    
    Calls CPUID to get CPU vendor and model. The strings will be put
    in AX and BX.

AH = 0xOD: hexToDecimal
    DX <= hexstring
    CX => number
    AX => status
    
    Tries to interpret the first to chars of DX as a hexadecimal number.
    Valid characters are 0-9, a-f and A-F. If this is successful, CX
    contains the number and AX is zero. Else, AX is -1 and CX is zero.

AH = 0x0E: set cursor position
    DH <= row
    DL <= column
    
    Sets the cursor to the position given in (DL, DH) [x, y] [0-79, 0-24].
    Values that are to big or to small get clamped to fit the screen.

AH = 0x0F: get cursor position
    DH => row
    DL => column
    
    Returns the cursor positon in (DL, DH) [x, y] [0-79, 0-24]
    
AH = 0x10: print a single character
    DL <= color code
    DH <= character

    Prints the character in the DH-register with the color in the DL-register
    to the screen and advances the cursor position.
    (The color code is refering to the standart BIOS-color codes, which
    encode the foreground color in 4 bits and the background color in the
    other 4 bits)

AH = 0x11: load root dir
    BP => offset address
    CX => maximum entry count (usually 224)
    
    Loads the root directory of the floppy to memory and returns a pointer
    to the beginning in BP and the number of entries in CX.

AH = 0x12: write root dir
    Writes the previously loaded root directory back to the floppy.
    
    WARNING: IT WONT CHECK THE ROOT DIRECTORY! THIS CAN DESTROY YOUR FILE SYSTEM!
    USE WITH CAUTON!

AH = 0x13: look for a file
    DX <= file name
    
    Checks if the file with the name given in DX exists. If the file is found
    AX contains the index of the file in the root directory, else AX is -1.

AH = 0x14: write file
    DX <= file name
    CX <= size in bytes
    BX <= segmentaddress of source buffer
    BP <= offsetaddress of source buffer
    AX => status (0 ok, -1 error)
    
    Creates the file with the file name in DX and writes CX bytes from the 
    source buffer to the floppy. 
    At the moment, you can not override files. To do this you have to delete
    the old file first.

AH = 0x15: decimalToHex
    CL <= number to convert (1 byte)
    DX <= destination string (3 bytes)
    
    Converts the byte in CL to a 2-digit hexadecimal string in DX. The string
    is \0-terminated which makes it 3-bytes long. 
    The string uses the characters 0-9 and A-F.

AH = 0x16: BCDtoInt
    AL <= BCD-Byte
    CX => integer
    
    Interprets the byte in AL as binary coded decimal and converts it
    to interger in CX.
    
    
Experimental [32-Bit ready]:


AH = 0xAA: intToString32
    DX <= destination string
    ECX <= integer
    
    Convert the integer in ECX to a string in DX. (positive and negative
    integers are supported)
    Make sure the string in DX has enough space. Maximum length is 11 bytes
    (including \0-character).

AH = 0xBB: stringToInt32
    DX <= destination string
    ECX => integer
    AX => status (-1 error, 0 ok)
    
    Converts the string in DX to an integer in ECX.
    If this is successful the ECX-register contains the integer and AX
    is zero, else ECX is zero and AX will be -1. This will read
    up to the first white space or \0-character.
    
    Warning: more than 9-digits will lead to incorrect results!
    
